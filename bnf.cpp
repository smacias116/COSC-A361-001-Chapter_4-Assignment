// PARSER

#include <iostream>
using namespace std;

// Prototypes to declare functions before definition:
void expr();    // This is used within factor() & assign() functions
void term();    // This is used within expr() function
void factor();  // This is used within term() function

// Parses strings in the language generated by the rule:    <expr>->    <term> {(+ | -) <term>}
void expr() 
{
    term();     // Parse the first term 
    // As long as the next token is + or -, get the next token and parse the next term
    while (nextToken == ADD_OP || nextToken == SUB_OP) 
    {
        lex();
        term();
    }
}

// Parses strings in the language generated by the rule:    <term>->    <factor> {(* | /) <factor>)
void term() 
{
    factor();   // Parse the first factor
    // As long as the next token is * or /, get the next token and parse the next factor
    while (nextToken == MUL_OP || nextToken == DIV_OP) 
    {
        lex();
        factor();
    }
}

// Parses strings in the language generated by the rule:    <factor>->  <ident> | <int_literal> | <float_literal> | ( <expr> )
void factor() 
{
    // Determine which RHS
    if (nextToken == VAR || nextToken == INT_LIT)
        lex();  // Get the next token
    else        // token is not identifier, integer literal or float literal
    { 
        if (nextToken == LEFT_PAREN)    // left paraenthsis found
        { 
            lex();                      // get next token
            expr();                     // parse expression
            if (nextToken == RIGHT_PAREN) 
                lex();                  // right paraenthsis found, get next token
            else 
                errMsg("Right parenthesis expected, found " + lexeme);
        }                               // End-if (nextToken == LEFT_PAREN)
        else 
            errMsg("expected var, integer literal, or left parenthesis, found " + lexeme);
    }
}

// Parses assignment statement by the rule:                 <assign>->  <identifier> = <expr>
void assign() 
{
    if (nextToken == VAR)           // identifier found
    { 
        if (!search_symbol(lexeme)) // if lexeme is not in symbol table 
        {
            errMsg("Undefined variable " + lexeme);
        } 
        lex();
        if (nextToken == ASSIGN_OP) // equal sign found
        { 
            lex(); // get next token
            expr(); // parse expression
        }
        else 
            errMsg("equal sign expected, found " + lexeme);
    }
    else 
        errMsg("Variable expected, found " + lexeme);
}

// Parses integer variable by the rule:                     <intVar>->  <ident> | <ident><intLit>   
void initializeVar() 
{
    string varName = lexeme;
    lex();
    if (nextToken == ASSIGN_OP) 
    {
        lex();                                 // get next token
        if (nextToken == INT_LIT) 
        {
            int value = atoi (lexeme.c_str());  // convert string to integer
            add_symbol(varName, value);        // add variable to the symbol table
            lex();
        }
        else errMsg ("Integer initialization expected, found " + lexeme);
    }
    else 
        add_symbol (varName, 0);
}

// integer identifier (variable) parser by the rule:        <intIdent>-><intVar> <intVar>*
void intVar() 
{
    if (nextToken == VAR) 
    {
        while (nextToken == VAR) 
        {
            initializeVar();
            if (nextToken == COMMA) 
                lex();
            else 
                break;
        }
    }
    else 
        errMsg ("Variable expected, fount " + lexeme);
}

//  Parses declaration statement by the rule                <ident>->   int <intIdent> | float <floatIdent>
void declaration() 
{
    lex();      // varialbe token expected
    intVar();
}

//  Statement parser by the rule:                           <stmt>->    <decl> | <assign>
void stmt() 
{
    if (nextToken == INT_KEYWORD) 
        declaration();     // parse declaration
    else 
        assign();          // parse assignment statement
}