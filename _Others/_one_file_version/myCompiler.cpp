//------------------------------------------------------------
// THIS PROGRAM ICNLUDES ALL FILES TOGETHER:    
//  "Globals.cpp", "symbolTable.cpp", "bnf.cpp", and "lex.cpp"
//  GO TO LINE 345 TO CHANGE INPUT FILE
//------------------------------------------------------------

#include <fstream>                   
#include <cstdlib>                    
#include <iostream>
#include <string>
using namespace std;

void lex();
void term();
void factor(); 

//-------------------------------Globals.cpp//-------------------------------

enum Tokens {INT_LIT, INT_KEYWORD, DECL, VAR, ASSIGN_OP, ADD_OP, SUB_OP, MUL_OP, DIV_OP,
            LEFT_PAREN, RIGHT_PAREN, LETTER, DIGIT, COMMA, UNKNOWN, ENDFILE};
const int MAX_SIZE = 100;   // maximum size per line
string lexeme = "";         // current lexeme
Tokens nextToken;
int errors = 0;             // keep track of number of errors
int line = 1;               // keep track of current line reached

// errMsg - function to display the error message with line number of error detected.
void errMsg (string msg) 
{
    cout << "Error at line: " << line << ": " << msg << endl;
    errors++;
    lex(); 
}


//-------------------------------symbolTable.cpp-----------------------------

struct item 
{
    string name;    // to store variable name
    int intValue;   // to store value
};
item symbolTable[100];
int ind = 0;    // index to top of symbol table

void add_symbol(string name, int value) 
{
    symbolTable[ind].name = name;
    symbolTable[ind].intValue = value;
    ind++;
}

void prt_symbol() 
{
    cout << "Symbol table:";
    cout << "Name\tValue\n";
    for (int i=0; i<ind; i++) 
    {
        cout << symbolTable[i].name << "\t" << symbolTable[i].intValue << endl;
    }
}

bool search_symbol (string lexeme) 
{
    for (int i=0; i<ind; i++)
        if (symbolTable[i].name == lexeme) 
            return true;
    return false;
}


//-------------------------------bnf.cpp-------------------------------------


// expr() Parses strings in the language generated by the rule:     <expr>      -> <term> {(+ | -) <term>}  
void expr() 
{
    term();     // Parse the first term 
    // As long as the next token is + or -, get the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP) 
    {
        lex();
        term();
    }
}

// term() Parses strings in the language generated by the rule:     <term>      -> <factor> {(* | /) <factor>)   
void term() 
{
    factor();   // Parse the first factor
    // As long as the next token is * or /, get the next token and parse the next factor
    while (nextToken == MUL_OP || nextToken == DIV_OP) 
    {
        lex();
        factor();
    }
}

// factor() Parses strings in the language generated by the rule:   <factor>    -> <ident> | <int_literal> | <float_literal> | ( <expr> )   
void factor() 
{
    // Determine which RHS
    if (nextToken == VAR || nextToken == INT_LIT)
        lex();      // Get the next token
    else            // token is not identifier, integer literal or float literal
    { 
        if (nextToken == LEFT_PAREN)    // left paraenthsis found
        { 
            lex();                      // get next token
            expr();                     // parse expression
            if (nextToken == RIGHT_PAREN) 
                lex();                  // right paraenthsis found, get next token
            else 
                errMsg("Right parenthesis expected, found " + lexeme);
        }                               // End-if (nextToken == LEFT_PAREN)

        else 
            errMsg("expected var, integer literal, or left parenthesis, found " + lexeme);
    }
}

// assign() Parses assignment statement by the rule:                <assign>    -> <identifier> = <expr>  
void assign() 
{
    if (nextToken == VAR)       // identifier found
    { 
        if (!search_symbol(lexeme))     // if lexeme is not in symbol table 
        {
            errMsg("Undefined variable " + lexeme);
        } 
        
        lex();

        if (nextToken == ASSIGN_OP)     // equal sign found
        { 
            lex(); // get next token
            expr(); // parse expression
        }
       
        else 
            errMsg ("equal sign expected, found " + lexeme);
    }
    
    else 
        errMsg("Variable expected, found " + lexeme);
}

// initializeVar () Parses integer variable by the rule:            <intVar>    -> <ident> | <ident><intLit>  
void initializeVar() 
{
    string varName = lexeme;

    lex();
    if (nextToken == ASSIGN_OP) 
    {
        lex();                                 // get next token
        if (nextToken == INT_LIT) 
        {
            int value = atoi(lexeme.c_str());  // convert string to integer
            add_symbol (varName, value);        // add variable to the symbol table
            lex();
        }
        else errMsg ("Integer initialization expected, found " + lexeme);
    }
    
    else 
        add_symbol(varName, 0);
}

// intVar() integer identifier (variable) parser by the rule:       <intIdent>  -> <intVar> <intVar>*    
void intVar() 
{
    if (nextToken == VAR) 
    {
        while (nextToken == VAR) 
        {
            initializeVar ();
            if (nextToken == COMMA) 
                lex();
            else 
                break;
        }
    }
    else 
        errMsg ("Variable expected, fount " + lexeme);
}

// declaration() Parses declaration statement by the rule           <ident>     -> int <intIdent> | float <floatIdent> 
void declaration() 
{
    lex();      // varialbe token expected
    intVar();
}

// stmt() Statement parser by the rule:                             <stmt>      -> <decl> | <assign>
void stmt() 
{
    if (nextToken == INT_KEYWORD) 
        declaration();     // parse declaration
    else 
        assign();          // parse assignment statement
}


//-------------------------------lex.cpp-------------------------------------MAIN INCLUDED HERE

ifstream infp;
// const int MAX_SIZE = 100;   // maximum size per line    // <---NOT NEDDED (already declared above)           
char nextChar = ' ';        // next character to read

// return a single character from a file
char getChar() 
{
    char c = infp.get();        
    if (c == '\n') line++;
        return c;

}

// skip spaces and return first non-space character from the file
char getNonSpaceChar() 
{
    char c = ' ';
    while (isspace(c)) 
    {
        c = getChar();
    }
    return c;
}

// add character to the lexeme string
void addChar(char c) 
{
    lexeme = lexeme + c;
    if (lexeme.length() > MAX_SIZE - 1) 
    {
        cout << "ERROR: lexeme too longâ€¦ \n";
        errors++;
    }
}

// lookupKeyword() determine if "lexeme" is a keyword or Var
Tokens lookupKeyword(string lexeme) 
{
    Tokens t;
    if (lexeme == "int") 
        t = INT_KEYWORD;
    else 
        t = VAR;
    return t;
}

Tokens lookupOp(string lexeme) 
{
    if (lexeme == "(") return LEFT_PAREN;
    if (lexeme == ")") return RIGHT_PAREN;
    if (lexeme == "+") return ADD_OP;
    if (lexeme == "-") return SUB_OP;
    if (lexeme == "/") return MUL_OP;
    if (lexeme == "*") return DIV_OP;
    if (lexeme == "=") return ASSIGN_OP;
    if (lexeme == ",") return COMMA;
    return UNKNOWN;
}

bool isOperator(char c) 
{
    if (c=='+' || c=='-' || c=='*' || c=='/' || c==',' || c=='(' || c==')' || c=='=') 
        return true;
    return false;
}

void prt (Tokens nt) 
{
    switch (nt) 
    {
        case LETTER: cout << "<Letter>"; break;
        case DIGIT: cout << "<DIGIT>"; break;
        case INT_KEYWORD: cout << "<INT_KEYWORD>"; break;
        case INT_LIT: cout << "<INT_LIT>"; break;
        case VAR: cout << "<VAR>"; break;
        case ASSIGN_OP: cout << "<ASSIGN>"; break;
        case ADD_OP: cout << "<ADD_OP>"; break;
        case SUB_OP: cout << "<SUB_OP>"; break;
        case MUL_OP: cout << "<MUL_OP>"; break;
        case DIV_OP: cout << "<DIV_OP>"; break;
        case LEFT_PAREN: cout << "<LEFT_PAREN>"; break;
        case RIGHT_PAREN: cout << "<RIGHT_PAREN>"; break;
        case COMMA: cout << "<COMMA>"; break;
        case ENDFILE: cout << "<ENDFILE>"; break;
        case UNKNOWN: cout << "Unknow "; break;
    }
}

void lex() 
{
    lexeme = "";

    if (isspace(nextChar)) 
        nextChar = getNonSpaceChar();

    if (isalpha(nextChar) || nextChar == '_') 
    {
        while (isalpha(nextChar) || isdigit(nextChar) || nextChar == '_') 
        {
            addChar(nextChar);
            nextChar = getChar();
        }
        nextToken = lookupKeyword(lexeme);
    }

    else if (isdigit(nextChar)) 
    {
        while (isdigit(nextChar)) 
        {
            addChar(nextChar);
            nextChar = getChar();
        }
        nextToken = INT_LIT;
    }

    else if (isOperator(nextChar)) 
    {
        while (isOperator(nextChar)) 
        {
            addChar(nextChar);
            nextChar = getChar();
        }
        
        nextToken = lookupOp(lexeme);
    }

    else if (nextChar == EOF) 
        nextToken = ENDFILE;

    else 
        nextToken = UNKNOWN;
    
    cout << "Next token is: "; prt (nextToken); cout << " Next lexeme is " << lexeme << endl;
}

int main() 
{
    string filename;
    filename = "prg1.in"; // <------------------------CHANGE INPUT FILE
    infp.open(filename);

    if (!infp) 
    {
        cout << "ERROR - cannot open " << filename << "\n";
        errors++;
        return 0;
    }

    //string str;  <---Not used
    lex();
    do 
    {
        stmt();
    } while (nextToken != ENDFILE);

    cout << "Total number of errors: " << errors << endl;

    return 0;
}